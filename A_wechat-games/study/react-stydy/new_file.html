<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<!--JS中有6种数据类型：Undefined、Null、Boolean、Number、String和Object。
		JS中不支持任何创建自定义类型的机制，而所有值最终都将是这6种数据类型。
		其数据类型的动态性特点足以表示所有数据。JS提供typeof操作符来检测变量的数据类型。
		
		
		undefined表示"缺少值"
		（1）变量被声明了，但没有赋值时，就等于undefined。

		   （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
		
		   （3）对象没有赋值的属性，该属性的值为undefined。
		
		   （4）函数没有返回值时，默认返回undefined。-->
		   
		   
		   
		常见浏览器兼容性问题与解决方案 
		   浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，
		   造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，
		   无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。
		   所以浏览器的兼容性问题是前端开发人员经常会碰到和必须要解决的问题。
		   
		   浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同
		   解决方案：CSS里    *{margin:0;padding:0;}
			   备注：		这个是最常见的也是最易解决的一个浏览器兼容性问题，
			   几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。
		浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
		
		问题症状:常见症状是IE6中后面的一块被顶到下一行

		碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）
		
		解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性
		
		备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，
		横向布局的时候我们通常都是用div float实现的，
		横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题
		
		浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度

		问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度
		
		碰到频率：60%
		
		解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。
		
		备注：这种情况一般出现在我们设置小圆角背景的标签里。
		出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，
		这个标签的高度还是会达到默认的行高。
		
		
		浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug
		
		问题症状：IE6里的间距比超过设置的间距

		碰到几率：20%
		
		解决方案：在display:block;后面加入display:inline;display:table;
		
		备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。
		在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。
		不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。
		这时候我们还需要在display:inline后面加入display:talbe。
		
		
		浏览器兼容问题五：图片默认有间距

		问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。
		
		碰到几率：20%
		
		解决方案：使用float属性为img布局
		
		备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，
		但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，
		但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）
		
		
		浏览器兼容问题六：标签最低高度设置min-height不兼容

		问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容
		
		碰到几率：5%
		
		解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：
		{min-height:200px; height:auto !important; height:200px; overflow:visible;}
		
		备注：在B/S系统前端开时，有很多情况下我们又这种需求。
		当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，
		容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。
		
		浏览器兼容问题七：透明度的兼容CSS设置
		
		做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，
		当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。
		很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，
		只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，
		就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。
		
		
		/* CSS hack*/ 
		我很少使用hacker的，可能是个人习惯吧，我不喜欢写的代码IE不兼容，然后用hack来解决。
		不过hacker还是非常好用的。使用hacker我可以把浏览器分为3类：
		IE6 ；IE7和遨游；其他（IE8 chrome ff safari opera等）
		
		◆IE6认识的hacker 是下划线_ 和星号 *
		
		◆IE7 遨游认识的hacker是星号 *
		
		比如这样一个CSS设置：
		
		height:300px;*height:200px;_height:100px; 
		IE6浏览器在读到height:300px的时候会认为高时300px；继续往下读，他也认识*heihgt，
		 所以当IE6读到*height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。
		 继续往下读，IE6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px；
		
		IE7和遨游也是一样的从高度300px的设置往下读。当它们读到*height200px的时候就停下了，
		因为它们不认识_height。所以它们会把高度解析为200px，剩下的浏览器只认识第一个height:300px;
		所以他们会把高度解析为300px。因为优先级相同且想冲突的属性设置后一个会覆盖掉前一个，
		所以书写的次序是很重要的。




		常用的hack技巧
		
		E Hack

		IE系列浏览器的hack大略如下：
		
		_nowamagic:1px;-----------ie6
		*nowamagic:1px;-----------ie7
		nowamagic:1px\0;----------ie89
		nowamagic:1px\9\0;--------ie9
		:root nowamagic:1px;    ----ie9(实际情况可能ie9还是有问题，再用这种方式)
		
		
		
		Firefox 与 Chrome 的 Hack
		@-moz-document url-prefix()    /*写在选择器外层时（只可写在此处）：Firefox only*/
		@media screen and (-webkit-min-device-pixel-ratio:0)    /*写在选择器外层时（只可写在此处）：Chrome only*/
		
		@-moz-document url-prefix()    /*Firefox*/
		{
		    body
		    {
		        background-color:pink;
		    }
		}
		浏览器对css的解析是从前到后的，并且采用最后一个样式声明。
		.color{
		    background-color: #CC00FF;         /*所有浏览器都会显示为紫色*/
		    background-color: #FF0000\9;       /*IE6、IE7、IE8会显示红色*/
		    *background-color: #0066FF;        /*IE6、IE7会变为蓝色*/            
		    _background-color: #009933;        /*IE6会变为绿色*/
		}
				background: red;            /* 对FF Opera和Safari有效 */
		#background: blue;          /* 对 IE6 和 IE7有效 */
		_background: green;         /* 只对IE6有效 */
		/*/background: orange;*/    /** 只对IE8有效 **/
		!important                  /*FF、IE7有效*/
		* 
		
		
		IE8是可以和IE7兼容的，简单一行代码，让IE8自动调用IE7的渲染模式。只需要在页面中加入如下HTTP meta-tag:<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7" />，只要IE8读到这个标签，它就会自动启动IE7兼容模式，保证页面完整展示。

		混用起来大约是这样：
		:root .demo {  
		    background:#963\9; /* 仅IE9适用 */  
		}  
		.demo {  
		    width: 300px;  
		    height: 200px;  
		    background: #036; /* 所有浏览器都适用 */  
		    background: #09F\9; /* IE6~IE9 */  
		    background: #09F\0; /* IE8~IE9 */  
		    background: #09F\0/; /* IE8 */  
		    *background: #F60; /* IE6/IE7 */  
		    +background: #F60; /* IE6/IE7 */  
		    @background: #F60; /* IE6/IE7 */  
		    >background: #F60; /* IE6/IE7 */  
		    _background: #ccc; /* IE6 */  
		}  
		@media all and (min-width:0) {  
		    .demo {  
		        background: #F06; /* webkit and opera */  
		    }  
		}  
		  
		@media screen and (-webkit-min-device-pixel-ratio:0){  
		    .demo {background:#609;}/*webkit (& Opera9.2)*/  
		}
		
		relative，absolute的定位原点
		1，relative（相对定位）的定位原点是以自己本省原来所在位置做为原点的。
		2，absolute（绝对定位）的定位原点是离自己这一级元素最近的一级position设置为absolute或者relative
		的父元素的左上角为原点的，
		（当然，如果自己的所有父元素都没有设置position，那么就以body为定位原点）
		
		
		
		块级元素：div  , p  , form,   ul,  li ,  ol, dl,    form,   address,  fieldset,  hr, menu,  table
   		行内元素：span,   strong,   em,  br,  img ,  input,  label,  select,  textarea,  cite, 
   		
   		2  区别：
		   1）块级元素会独占一行，其宽度自动填满其父元素宽度
		        行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容      
		           而变化
		   2） 块级元素可以设置 width, height属性，行内元素设置width,  height无效
		         【注意：块级元素即使设置了宽度，仍然是独占一行的】
		   3) 块级元素可以设置margin 和 padding.  行内元素的水平方向的padding-left,padding-right,margin-left,
		   margin-right 都产生边距效果，但是竖直方向的padding-top,padding-bottom,margin-top,
		   margin-bottom都不会产生边距效果。
		   （水平方向有效，竖直方向无效）
	</body>
	<script>
		var name ="boss";
		var object = {
			name:"me",
			getName:function(){
				return function(){
					return this.name;//没有任何 调用 this　this指向dom
					//return object.name;//弹出的 是me
				};
			}
		};
		alert(object.getName()());//boss
	</script>
</html>
